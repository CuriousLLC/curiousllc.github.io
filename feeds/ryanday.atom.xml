<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>Working with hardware</title><link href="http://projects.curiousllc.com/" rel="alternate"></link><link href="http://projects.curiousllc.com/feeds/ryanday.atom.xml" rel="self"></link><id>http://projects.curiousllc.com/</id><updated>2015-05-25T20:05:00-04:00</updated><entry><title>Test driven API integration with Go</title><link href="http://projects.curiousllc.com/test-driven-api-integration-with-go.html" rel="alternate"></link><updated>2015-05-25T20:05:00-04:00</updated><author><name>ryanday</name></author><id>tag:projects.curiousllc.com,2015-05-25:test-driven-api-integration-with-go.html</id><summary type="html">&lt;p&gt;Test Driven design is more than simply testing individual functions before you write then. There are several components of your API client that you want to address:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;How the workflow will appear from a user's perspective.&lt;/li&gt;
&lt;li&gt;How the API meta control will work (pages, a cursor, offset/limit, authenticate, this sort of thing).&lt;/li&gt;
&lt;li&gt;How the backend API developers will shake their heads as you call the same method over and over during testing.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;We want to find a testing method that solves all these concerns. We should verify our core functionality is working. Then we can play with the user's workflow and test out different ideas without breaking that functionality. We can implement caching, iterating large data, or pieces of data, on top of the API after the tests are complete. Having the tests in place gives us the freedom to experiment.&lt;/p&gt;
&lt;p&gt;As always, let's check out Github to see how others are testing their client side APIs. There are lots of examples of course, but the common methods boil down to:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;Use a key and the live API (&lt;a class="reference external" href="https://github.com/ChimeraCoder/anaconda/blob/master/twitter_test.go"&gt;twitter&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;Don't test the actual calls, just the response handling (&lt;a class="reference external" href="https://github.com/facebookgo/fbapi"&gt;facebook&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;Mock very short responses to test calls (&lt;a class="reference external" href="https://github.com/MariaTerzieva/gotumblr/blob/master/gotumblr_test.go"&gt;tumblr&lt;/a&gt;, &lt;a class="reference external" href="https://github.com/masci/flickr/blob/master/testutils.go"&gt;flikr&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;Use a mix of mocks and live (&lt;a class="reference external" href="https://github.com/google/go-github/tree/master/tests"&gt;google github&lt;/a&gt;)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Each of these examples is worth taking a look at. Of these, Google's seems the most complete. Their test setup creates a global Mux and httptest.Server for that Mux. Each unit test attaches a handler to the Mux. They also have live tests that don't run in their CI. These are specifically to test whether server side functionality has changed.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Mocking the calls&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Really, we want to test the API as the user would consume it. We don't want to simply test all the little pieces and assume a nice workflow. So we need to write a test like the user would write their code.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;api := CreateNewApi(&amp;amp;client)

controlChan := make(chan bool)
responseChan, _ := api.SomeMethod(controlChan)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;CreateNewApi() most likely has us speaking with the actual API server. The API url is hardcoded in the library somewhere. So our test will probably hit the live server. Using the live API for testing violates my third concern. Fortunately we can rewrite the client's transport method to point to a test server. We do this with http.RoundTripper.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;type RewriteTransport struct {
        Transport http.RoundTripper
        URL       *url.URL
}

func (t RewriteTransport) RoundTrip(req *http.Request) (*http.Response, error) {
        // note that url.URL.ResolveReference doesn&amp;#39;t work here
        // since t.u is an absolute url
        req.URL.Scheme = t.URL.Scheme
        req.URL.Host = t.URL.Host
        req.URL.Path = path.Join(t.URL.Path, req.URL.Path)
        rt := t.Transport
        if rt == nil {
                rt = http.DefaultTransport
        }
        return rt.RoundTrip(req)
}

client := &amp;amp;http.Client{
        Transport: RewriteTransport{
                URL: testUrl,
        },
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;Minimal response test&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;With the custom transport, we are able to implement handlers for our tests. These handlers can return minimal expected responses. Take Flickr for example:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;// https://github.com/masci/flickr/blob/master/response_test.go
func TestExtra(t *testing.T) {
        bodyStr := `&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;utf-8&amp;quot; ?&amp;gt;
                &amp;lt;rsp stat=&amp;quot;ok&amp;quot;&amp;gt;
                        &amp;lt;user id=&amp;quot;23148015@N00&amp;quot;&amp;gt;
                        &amp;lt;username&amp;gt;Massimiliano Pippi&amp;lt;/username&amp;gt;
                        &amp;lt;/user&amp;gt;
                        &amp;lt;brands&amp;gt;
                          &amp;lt;brand id=&amp;quot;apple&amp;quot;&amp;gt;Apple&amp;lt;/brand&amp;gt;
                        &amp;lt;/brands&amp;gt;
                &amp;lt;/rsp&amp;gt;`

        flickrResp := &amp;amp;BasicResponse{}

        response := &amp;amp;http.Response{}    // HL
        response.Body = NewFakeBody(bodyStr)    // HL
        err := parseApiResponse(response, flickrResp)   // HL
        Expect(t, err, nil)
        Expect(t, flickrResp.Extra != &amp;quot;&amp;quot;, true)
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Flickr uses a transport rewrite to provide a minimal response to test. This gets us away from using the live API to test data. But the method being testing is parseApiResponse(). This isn't how the user will implement the API.&lt;/p&gt;
&lt;p&gt;This Tumblr API uses the same minimal response method. It also tests functions in the same way a user would call them.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;// https://github.com/MariaTerzieva/gotumblr/blob/master/gotumblr_test.go
func TestFollowing(t *testing.T) {
        setup()
        defer teardown()

        handleFunc(&amp;quot;/v2/user/following&amp;quot;, &amp;quot;GET&amp;quot;, `{&amp;quot;response&amp;quot;: {&amp;quot;total_blogs&amp;quot;: 1}}`, map[string]string{}, t)

        following := client.Following(map[string]string{}).Total_blogs
        want := int64(1)
        if following != want {
                t.Errorf(&amp;quot;Following returned %+v, want %v&amp;quot;, following, want)
        }
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;Hosting test data&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;This is a method I've been using that I haven't seen in the wild. It takes advantage of all the API consoles out there. You make a call using the provider's API console in a sandbox, and copy the (usually) JSON response into your test_data/ directory. Then simply serve the appropriate JSON file during the test.&lt;/p&gt;
&lt;p&gt;Using a recent integration for the Lingotek API, here is an example directory structure:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;src/
  lingotek/
    test_data/
      projects_full.json
      projects_three.json
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;These two json files contain a full API response, including headers, offset/limit/total counts, and other meta information. In our mock handler, we can control which of those files is served based on query parameters.&lt;/p&gt;
&lt;p&gt;To begin, we have a function which takes a channel for returning a *http.Request, and a function which returns the name of the file which contains our appropriate response.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;func createTestServer(requestChan chan *http.Request, getFileName func(*http.Request) string) httptest.Server, http.Client) {
        handler := http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
                var testData io.Reader
                var err error

                // getFileName will determine which response to load based on the request
                testData, err = os.Open(getFileName(r))
                if err != nil {
                        http.NotFound(w, r)
                        return
                }

                io.Copy(w, testData)

                requestChan &amp;lt;- r
        })

        server := httptest.NewServer(handler)
        testUrl, _ := url.Parse(server.URL)

        client := http.Client{
                Transport: RewriteTransport{
                        URL: testUrl,
                },
        }

        // Return our test server and a client which points to it
        return server, client
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Using this test server and client, we write a test like this:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;func TestGetProjects(t *testing.T) {

        // This is a simple handler, we always return the same response file
        f := func(r *http.Request) string {
                return &amp;quot;test_data/projects_full.json&amp;quot;
        }

        rCh := make(chan *http.Request, 1)
        server, client := createTestServer(rCh, f)
        defer server.Close()
        defer close(rCh)

        api := NewApi(&amp;quot;dummyToken&amp;quot;, &amp;amp;client)
        resp, err := api.GetProjectsPage(0, 10)
        if err != nil {
                t.Error(err)
        }

        if len(resp) != 10 {
                t.Errorf(&amp;quot;Expected 10 projects, got %d\n&amp;quot;, len(resp))
        }
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;But we can get more complex. Let's say we want to test our ListProject function. ListProject() returns a channel that the caller can iterate over. Since the ListProject API method only returns 10 objects at a time, our method must make the call again at a new offset. Then the method must send the new objects to the channel.&lt;/p&gt;
&lt;p&gt;Our mockHandler function has inspect the request, and send a different response for the different offset.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;mockHandler := func(r *http.Request) (fileName string) {
        offset := r.URL.Query().Get(&amp;quot;offset&amp;quot;)

        // If our client requested the next page,
        // send a different json response
        if offset == &amp;quot;10&amp;quot; {
                fileName = &amp;quot;test_data/projects_three.json&amp;quot;
        } else {
                fileName = &amp;quot;test_data/projects_full.json&amp;quot;
        }

        return
}

/* . . . */
doneChan := make(chan bool)
projectChan, _ := api.ListProjects(doneChan)

cNum := 0
for _ = range projectChan {
        cNum += 1
}

if cNum != 13 {
        t.Errorf(&amp;quot;Expected 13 projects, got %d&amp;quot;, cNum)
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This test verifies that we can iterate over a channel while the API method is making multiple calls to the backend.&lt;/p&gt;
&lt;p&gt;Full source is on &lt;a class="reference external" href="https://github.com/CuriousLLC/Lingotek"&gt;Github&lt;/a&gt;.&lt;/p&gt;
</summary></entry><entry><title>Examining SQLAlchemy Memory Usage</title><link href="http://projects.curiousllc.com/examining-sqlalchemy-memory-usage.html" rel="alternate"></link><updated>2015-03-20T18:22:00-04:00</updated><author><name>ryanday</name></author><id>tag:projects.curiousllc.com,2015-03-20:examining-sqlalchemy-memory-usage.html</id><summary type="html">&lt;p&gt;I started having segfaults in my celery processes. These were incredibly difficult to debug because they didn’t always happen, and never happened in development. Fortunately they were happening in certain places and I was able to guess where the problem was. However, I didn’t understand just how severe the problem was.&lt;/p&gt;
&lt;p&gt;I use SQLAlchemy in my Flask apps. I typically issue queries similar to&lt;/p&gt;
&lt;p&gt;query_result = db.session.query(MyModel).first()&lt;/p&gt;
&lt;p&gt;I knew I was running out of memory on my entry level Digital Ocean droplets.
That is when the segfaults started. I stumbled across &lt;a class="reference external" href="https://pypi.python.org/pypi/memory_profiler"&gt;Memory Profiler&lt;/a&gt; and
created a quick test program to profile a single function that was causing problems.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;Line # Mem usage Increment Line Contents
================================================
56 46.0 MiB 0.0 MiB   @profile
57                    def get_bounced_emails():
58 48.2 MiB 2.2 MiB       emails = db.session.query(EmailAddress).\
59 48.3 MiB 0.0 MiB           join(send_history, send_history.c.email_id == EmailAddress.email_id).\
60 372.1 MiB 323.9 MiB        filter(send_history.c.bounce == 1).\
61                            all()
62
63 372.1 MiB 0.0 MiB      email_dict = {}
64 374.1 MiB 2.0 MiB      for email in emails:
65 374.1 MiB 0.0 MiB          email_dict[email.email_address] = True
66
67 314.9 MiB -59.2 MiB    del emails
68 314.9 MiB 0.0 MiB      return email_dict
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The memory profiler package makes it real easy to see the memory consumption of your application line by line. In this function, we are just retrieving a ton of records. They are taking up a lot of memory.&lt;/p&gt;
&lt;p&gt;This is where I learned a little bit about SQLAlchemy. This function only needs the email_address field of the record, but I’m retrieving the entire record. So I made a change to simply grab the email_address record.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;Line # Mem usage Increment Line Contents
================================================
56 46.0 MiB 0.0 MiB   @profile
57                    def get_bounced_emails():
58 47.1 MiB 1.1 MiB       emails = db.session.query(EmailAddress.email_address).\
59 47.1 MiB 0.0 MiB           join(send_history, send_history.c.email_id == EmailAddress.email_id).\
60 81.2 MiB 34.1 MiB          filter(send_history.c.bounce == 1).\
61                            all()
62
63 81.2 MiB 0.0 MiB       email_dict = {}
64 84.2 MiB 3.0 MiB       for email in emails:
65 84.2 MiB 0.0 MiB           email_dict[email[0]] = True
66
67 65.9 MiB -18.2 MiB     del emails
68 65.9 MiB 0.0 MiB       return email_dict
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Wow. By just grabbing that one field I seriously reduced the memory consumption of this method. I had under estimated just how much overhead there is in pulling the entire record in a query.&lt;/p&gt;
&lt;p&gt;Now I take this into account when building queries. Just what do I need form the DB? Then I only grab that.&lt;/p&gt;
</summary></entry></feed>